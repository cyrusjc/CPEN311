
//===================********TASK 1********======================
// THIS MODULE CONTROLS ALL SUB FSMS. GIVES START AND FINISH TO FSM AS WELL AS 
// HAS MUX TO CONTROL WHICH ADDRESS WE USE.
//===========================================================

module master_fsm(
	input init_finish;
	output init_start;
	input swap_finish;
	output swap_start;
	input decode_finish;
	output decode_start;
	output [1:0] addr_data_sel;
);
			
parameter start_init 		= 10'b00_0000_0001;
parameter wait_init 		= 10'b00_0000_0000;
parameter finish_init 		= 10'b00_0000_0000;
parameter start_swap		= 10'b00_0001_0010;
parameter wait_swap 		= 10'b00_0001_0000;
parameter finish_swap		= 10'b00_0001_0000;
parameter start_decode  	= 10'b00_0010_0100;
parameter wait_decode 		= 10'b00_0010_0000;
parameter finish_decode 	= 10'b00_0010_0000;
reg [5:0] state;


assign init_start  = state[0];
assign swap_start  = state[1];
assign decode_start = state [2];
assign addr_data_sel = state [5:4];

//==================================================================
// 						OUR STATE MACHINE
//==================================================================
always_ff @(posedge clock) begin

	case(state)
	
		start_init:		state <= wait_init;
		
		wait_init:		if (init_finish)
							state <= finish_init;
						else
							state <= wait_init;
		
		finish_init:	state <= start_swap;
		
		start_swap:		state <= wait_swap;
		
		wait_swap:		if (init_finish)
							state <= finish_swap;
						else
							state <= wait_swap;
		
		finish_swap:	state <= start_decode;
		
		start_decode:	state <= wait_decode;
		
		wait_decode:	if (init_finish)
							state <= finish_decode;
						else
							state <= wait_decode;
		
		finish_decode:	state <= finish_decode;
		
		default	: 		state <= s_wait;

	endcase 
end

endmodule