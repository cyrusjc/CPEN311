KCPSM3  v1.30.      Ken Chapman (Xilinx-UK) 2005

The assembler for KCPSM3 Programmable State Machine

PASS 1 - Reading input PSM file

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_0, 40    ;OUTPUT DATA PORT FOR SINGLE BLINKING LED
CONSTANT LED_PORT, 80               ;8 simple LEDs. Is an OUTPUT port.
CONSTANT AUDIO_1, 00         ;input data port. this is an INPUT port.
CONSTANT AUDIO_2, 01         ;input data port. this is an INPUT port.
CONSTANT AUDIO_3, 02         ;input data port. this is an INPUT port.
CONSTANT AUDIO_4, 04         ;input data port. this is an INPUT port.
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s4, 04        ;Preserve s3 contents during ISR
;
CONSTANT SUM, 04            ;SUM OF THE ADDRESSES
CONSTANT COUNT, 06   ;COUNT UP TO 255
CONSTANT SUM_CARRY, 07  ;CARRY OF SUM USED TO OUTPUT LED
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F       ;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D           ;carriage return
CONSTANT character_question, 3F     ;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21      ;'!'
CONSTANT character_BS, 08           ;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00                         ;CLEAR ALL
STORE s0, SUM
STORE s0, COUNT
STORE s0, SUM_CARRY
OUTPUT s0, LED_PORT
OUTPUT s0, LED_0
;
ENABLE INTERRUPT
;
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program:
LOAD s1, 01
OUTPUT s1, LED_0   ; PUTS 1 INTO LED_0 (TURNS ON LED)
CALL delay_1s    ;WAITS 1 SECOND TO TURN OFF
load s1, 00
OUTPUT s1, LED_0   ; PUTS 0 INTO LED_0, (TURNS OFF LED)
CALL delay_1s    ;WAITS ANOTEHR SECOND TO TURN ON
JUMP main_program
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s1, ISR_preserve_s0           ;preserve register
STORE s2, ISR_preserve_s1
STORE s3, ISR_preserve_s2
FETCH s1, SUM                  ;read current sum value
FETCH s2, SUM_CARRY      ;read carryout of the sums
FETCH s3, COUNT      ;reads count
;;===================== ADD FIRST BYTE ================================
INPUT s5, AUDIO_1     ;INPUT INTO 1st BYTE
COMPARE s5, 80      ;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_1      ;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01       ;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_1: ADD s1, s5       ;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00      ;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01       ;INCREMENT COUNTER
;;===================== ADD SECOND BYTE ================================
INPUT s5, AUDIO_2     ;INPUT INTO 1st BYTE
COMPARE s5, 80      ;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_2      ;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01       ;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_2: ADD s1, s5       ;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00      ;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01       ;INCREMENT COUNTER
;;===================== ADD THIRD BYTE ================================
INPUT s5, AUDIO_3     ;INPUT INTO 1st BYTE
COMPARE s5, 80      ;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_3      ;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01       ;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_3: ADD s1, s5       ;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00      ;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01       ;INCREMENT COUNTER
;;===================== ADD FOURTH BYTE ================================
INPUT s5, AUDIO_4     ;INPUT INTO 1st BYTE
COMPARE s5, 80      ;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_4      ;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01       ;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_4: ADD s1, s5       ;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00      ;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01       ;INCREMENT COUNTER
;;============================================================
COMPARE s3, 00      ;IF COUNTER IS NOT 0 (OVER FLOW OF 255+1)
JUMP NZ, return      ;END INSTRUCTIOn
COMPARE s2, 80      ;IS IT BIGGER THAN 1000_0000?
JUMP C, H40       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, ff       ; LOAD WITH 1111_1111
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H40:  COMPARE s2, 40      ;IS IT BIGGER THAN 100_0000?
JUMP C, H20       ; IF ITS NOT JUMP TO H20 AND THEN COMPARE
LOAD s2, fe       ; LOAD WITH 1111_1110
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H20:  COMPARE s2, 20      ;IS IT BIGGER THAN 10_0000?
JUMP C, H10       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, fc       ; LOAD WITH 1111_1100
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H10:  COMPARE s2, 10      ;IS IT BIGGER THAN 1_0000?
JUMP C, H08       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, f8       ; LOAD WITH 1111_1000
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H08:  COMPARE s2, 08      ;IS IT BIGGER THAN 1000?
JUMP C, H04       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, f0       ; LOAD WITH 1111_0000
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H04:  COMPARE s2, 04      ;IS IT BIGGER THAN 100?
JUMP C, H02       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, e0       ; LOAD WITH 1110_0000
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H02:  COMPARE s2, 02      ;IS IT BIGGER THAN 10?
JUMP C, H01       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, c0       ; LOAD WITH 1100_0000
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H01:  COMPARE s2, 01      ;IS IT BIGGER THAN 1?
JUMP C, H00       ; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, 80       ; LOAD WITH 1000_0000
JUMP OUTPUT_LED      ; OUTPUTS IT INTO LED
H00:  LOAD s2, 00       ; LOAD WITH 0
OUTPUT_LED: OUTPUT s2, LED_PORT                 ;display counter value on LEDs
LOAD s1, 00       ;RESET SUM
load s2, 00       ;RESET SUM_CARRY
LOAD s3, 00       ;RESET COUNTER
return: STORE s1, SUM               ;store new counter value
STORE s2, SUM_CARRY
STORE s3, COUNT    ;STORE COUNTER VALUE
FETCH s1, ISR_preserve_s0           ;restore registers
FETCH s2, ISR_preserve_s1
FETCH s3, ISR_preserve_s2
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 2 - Testing Instructions

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_0, 40;OUTPUT DATA PORT FOR SINGLE BLINKING LED
CONSTANT LED_PORT, 80;8 simple LEDs. Is an OUTPUT port.
CONSTANT AUDIO_1, 00;input data port. this is an INPUT port.
CONSTANT AUDIO_2, 01;input data port. this is an INPUT port.
CONSTANT AUDIO_3, 02;input data port. this is an INPUT port.
CONSTANT AUDIO_4, 04;input data port. this is an INPUT port.
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
;
CONSTANT SUM, 04;SUM OF THE ADDRESSES
CONSTANT COUNT, 06;COUNT UP TO 255
CONSTANT SUM_CARRY, 07;CARRY OF SUM USED TO OUTPUT LED
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D;carriage return
CONSTANT character_question, 3F;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21;'!'
CONSTANT character_BS, 08;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00;CLEAR ALL
STORE s0, SUM
STORE s0, COUNT
STORE s0, SUM_CARRY
OUTPUT s0, LED_PORT
OUTPUT s0, LED_0
;
ENABLE INTERRUPT
;
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: 
LOAD s1, 01
OUTPUT s1, LED_0; PUTS 1 INTO LED_0 (TURNS ON LED)
CALL delay_1s;WAITS 1 SECOND TO TURN OFF
load s1, 00
OUTPUT s1, LED_0; PUTS 0 INTO LED_0, (TURNS OFF LED)
CALL delay_1s;WAITS ANOTEHR SECOND TO TURN ON
JUMP main_program
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s1, ISR_preserve_s0;preserve register
STORE s2, ISR_preserve_s1
STORE s3, ISR_preserve_s2
FETCH s1, SUM;read current sum value
FETCH s2, SUM_CARRY;read carryout of the sums
FETCH s3, COUNT;reads count
;;===================== ADD FIRST BYTE ================================
INPUT s5, AUDIO_1;INPUT INTO 1st BYTE
COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_1;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_1: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01;INCREMENT COUNTER
;;===================== ADD SECOND BYTE ================================
INPUT s5, AUDIO_2;INPUT INTO 1st BYTE
COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_2;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_2: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01;INCREMENT COUNTER
;;===================== ADD THIRD BYTE ================================
INPUT s5, AUDIO_3;INPUT INTO 1st BYTE
COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_3;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_3: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01;INCREMENT COUNTER
;;===================== ADD FOURTH BYTE ================================
INPUT s5, AUDIO_4;INPUT INTO 1st BYTE
COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
JUMP C, ADD_BYTE_4;jump if S2 < 80 (POSITIVE NUMBER)
;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
XOR s5, ff
ADD s5, 01;CONVERTING 2's COMPLEMENT
;; ADDS THIS TO SUM
ADD_BYTE_4: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
ADD s3, 01;INCREMENT COUNTER
;;============================================================
COMPARE s3, 00;IF COUNTER IS NOT 0 (OVER FLOW OF 255+1)
JUMP NZ, return;END INSTRUCTIOn
COMPARE s2, 80;IS IT BIGGER THAN 1000_0000?
JUMP C, H40; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, ff; LOAD WITH 1111_1111
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H40: COMPARE s2, 40;IS IT BIGGER THAN 100_0000?
JUMP C, H20; IF ITS NOT JUMP TO H20 AND THEN COMPARE
LOAD s2, fe; LOAD WITH 1111_1110
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H20: COMPARE s2, 20;IS IT BIGGER THAN 10_0000?
JUMP C, H10; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, fc; LOAD WITH 1111_1100
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H10: COMPARE s2, 10;IS IT BIGGER THAN 1_0000?
JUMP C, H08; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, f8; LOAD WITH 1111_1000
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H08: COMPARE s2, 08;IS IT BIGGER THAN 1000?
JUMP C, H04; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, f0; LOAD WITH 1111_0000
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H04: COMPARE s2, 04;IS IT BIGGER THAN 100?
JUMP C, H02; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, e0; LOAD WITH 1110_0000
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H02: COMPARE s2, 02;IS IT BIGGER THAN 10?
JUMP C, H01; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, c0; LOAD WITH 1100_0000
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H01: COMPARE s2, 01;IS IT BIGGER THAN 1?
JUMP C, H00; IF ITS NOT JUMP TO H40 AND THEN COMPARE
LOAD s2, 80; LOAD WITH 1000_0000
JUMP OUTPUT_LED; OUTPUTS IT INTO LED
H00: LOAD s2, 00; LOAD WITH 0
OUTPUT_LED: OUTPUT s2, LED_PORT;display counter value on LEDs
LOAD s1, 00;RESET SUM
load s2, 00;RESET SUM_CARRY
LOAD s3, 00;RESET COUNTER
return: STORE s1, SUM;store new counter value
STORE s2, SUM_CARRY
STORE s3, COUNT;STORE COUNTER VALUE
FETCH s1, ISR_preserve_s0;restore registers
FETCH s2, ISR_preserve_s1
FETCH s3, ISR_preserve_s2
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 3 - Resolving addresses and line labels

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_0, 40;OUTPUT DATA PORT FOR SINGLE BLINKING LED
000 CONSTANT LED_PORT, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT AUDIO_1, 00;input data port. this is an INPUT port.
000 CONSTANT AUDIO_2, 01;input data port. this is an INPUT port.
000 CONSTANT AUDIO_3, 02;input data port. this is an INPUT port.
000 CONSTANT AUDIO_4, 04;input data port. this is an INPUT port.
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
000 ;
000 CONSTANT SUM, 04;SUM OF THE ADDRESSES
000 CONSTANT COUNT, 06;COUNT UP TO 255
000 CONSTANT SUM_CARRY, 07;CARRY OF SUM USED TO OUTPUT LED
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00;CLEAR ALL
001 STORE s0, SUM
002 STORE s0, COUNT
003 STORE s0, SUM_CARRY
004 OUTPUT s0, LED_PORT
005 OUTPUT s0, LED_0
006 ;
006 ENABLE INTERRUPT
007 ;
007 
;**************************************************************************************
007 ; Main program
007 
;**************************************************************************************
007 ;
007 ; Display welcome message for design
007 ;
007 main_program: 
007 LOAD s1, 01
008 OUTPUT s1, LED_0; PUTS 1 INTO LED_0 (TURNS ON LED)
009 CALL delay_1s;WAITS 1 SECOND TO TURN OFF
00A LOAD s1, 00
00B OUTPUT s1, LED_0; PUTS 0 INTO LED_0, (TURNS OFF LED)
00C CALL delay_1s;WAITS ANOTEHR SECOND TO TURN ON
00D JUMP main_program
00E 
;**************************************************************************************
00E ; Software delay routines
00E 
;**************************************************************************************
00E ;
00E ; Delay of 1us.
00E ;
00E 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00E 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00E 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00E ; in the initiating code. Interrupts may effect software derived delays.
00E ;
00E 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00E ;
00E ; Registers used s0
00E ;
00E delay_1us: LOAD s0, delay_1us_constant
00F wait_1us: SUB s0, 01
010 JUMP NZ, wait_1us
011 RETURN
012 ;
012 ; Delay of 40us.
012 ;
012 ; Registers used s0, s1
012 ;
012 delay_40us: LOAD s1, 28;40 x 1us = 40us
013 wait_40us: CALL delay_1us
014 SUB s1, 01
015 JUMP NZ, wait_40us
016 RETURN
017 ;
017 ;
017 ; Delay of 1ms.
017 ;
017 ; Registers used s0, s1, s2
017 ;
017 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
018 wait_1ms: CALL delay_40us
019 SUB s2, 01
01A JUMP NZ, wait_1ms
01B RETURN
01C ;
01C ; Delay of 20ms.
01C ;
01C ; Delay of 20ms used during initialisation.
01C ;
01C ; Registers used s0, s1, s2, s3
01C ;
01C delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
01D wait_20ms: CALL delay_1ms
01E SUB s3, 01
01F JUMP NZ, wait_20ms
020 RETURN
021 ;
021 ; Delay of approximately 1 second.
021 ;
021 ; Registers used s0, s1, s2, s3, s4
021 ;
021 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
022 wait_1s: CALL delay_20ms
023 SUB s4, 01
024 JUMP NZ, wait_1s
025 RETURN
026 ;
026 
;**************************************************************************************
026 ; Interrupt Service Routine (ISR)
026 
;**************************************************************************************
026 ;
026 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
026 ; on the 8 LEDs.
026 ;
026 ISR: STORE s1, ISR_preserve_s0;preserve register
027 STORE s2, ISR_preserve_s1
028 STORE s3, ISR_preserve_s2
029 FETCH s1, SUM;read current sum value
02A FETCH s2, SUM_CARRY;read carryout of the sums
02B FETCH s3, COUNT;reads count
02C ;;===================== ADD FIRST BYTE ================================
02C INPUT s5, AUDIO_1;INPUT INTO 1st BYTE
02D COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
02E JUMP C, ADD_BYTE_1;jump if S2 < 80 (POSITIVE NUMBER)
02F ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
02F XOR s5, ff
030 ADD s5, 01;CONVERTING 2's COMPLEMENT
031 ;; ADDS THIS TO SUM
031 ADD_BYTE_1: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
032 ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
033 ADD s3, 01;INCREMENT COUNTER
034 ;;===================== ADD SECOND BYTE ================================
034 INPUT s5, AUDIO_2;INPUT INTO 1st BYTE
035 COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
036 JUMP C, ADD_BYTE_2;jump if S2 < 80 (POSITIVE NUMBER)
037 ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
037 XOR s5, ff
038 ADD s5, 01;CONVERTING 2's COMPLEMENT
039 ;; ADDS THIS TO SUM
039 ADD_BYTE_2: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
03A ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
03B ADD s3, 01;INCREMENT COUNTER
03C ;;===================== ADD THIRD BYTE ================================
03C INPUT s5, AUDIO_3;INPUT INTO 1st BYTE
03D COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
03E JUMP C, ADD_BYTE_3;jump if S2 < 80 (POSITIVE NUMBER)
03F ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
03F XOR s5, ff
040 ADD s5, 01;CONVERTING 2's COMPLEMENT
041 ;; ADDS THIS TO SUM
041 ADD_BYTE_3: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
042 ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
043 ADD s3, 01;INCREMENT COUNTER
044 ;;===================== ADD FOURTH BYTE ================================
044 INPUT s5, AUDIO_4;INPUT INTO 1st BYTE
045 COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
046 JUMP C, ADD_BYTE_4;jump if S2 < 80 (POSITIVE NUMBER)
047 ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
047 XOR s5, ff
048 ADD s5, 01;CONVERTING 2's COMPLEMENT
049 ;; ADDS THIS TO SUM
049 ADD_BYTE_4: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
04A ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
04B ADD s3, 01;INCREMENT COUNTER
04C ;;============================================================
04C COMPARE s3, 00;IF COUNTER IS NOT 0 (OVER FLOW OF 255+1)
04D JUMP NZ, return;END INSTRUCTIOn
04E COMPARE s2, 80;IS IT BIGGER THAN 1000_0000?
04F JUMP C, H40; IF ITS NOT JUMP TO H40 AND THEN COMPARE
050 LOAD s2, ff; LOAD WITH 1111_1111
051 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
052 H40: COMPARE s2, 40;IS IT BIGGER THAN 100_0000?
053 JUMP C, H20; IF ITS NOT JUMP TO H20 AND THEN COMPARE
054 LOAD s2, fe; LOAD WITH 1111_1110
055 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
056 H20: COMPARE s2, 20;IS IT BIGGER THAN 10_0000?
057 JUMP C, H10; IF ITS NOT JUMP TO H40 AND THEN COMPARE
058 LOAD s2, fc; LOAD WITH 1111_1100
059 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
05A H10: COMPARE s2, 10;IS IT BIGGER THAN 1_0000?
05B JUMP C, H08; IF ITS NOT JUMP TO H40 AND THEN COMPARE
05C LOAD s2, f8; LOAD WITH 1111_1000
05D JUMP OUTPUT_LED; OUTPUTS IT INTO LED
05E H08: COMPARE s2, 08;IS IT BIGGER THAN 1000?
05F JUMP C, H04; IF ITS NOT JUMP TO H40 AND THEN COMPARE
060 LOAD s2, f0; LOAD WITH 1111_0000
061 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
062 H04: COMPARE s2, 04;IS IT BIGGER THAN 100?
063 JUMP C, H02; IF ITS NOT JUMP TO H40 AND THEN COMPARE
064 LOAD s2, e0; LOAD WITH 1110_0000
065 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
066 H02: COMPARE s2, 02;IS IT BIGGER THAN 10?
067 JUMP C, H01; IF ITS NOT JUMP TO H40 AND THEN COMPARE
068 LOAD s2, c0; LOAD WITH 1100_0000
069 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
06A H01: COMPARE s2, 01;IS IT BIGGER THAN 1?
06B JUMP C, H00; IF ITS NOT JUMP TO H40 AND THEN COMPARE
06C LOAD s2, 80; LOAD WITH 1000_0000
06D JUMP OUTPUT_LED; OUTPUTS IT INTO LED
06E H00: LOAD s2, 00; LOAD WITH 0
06F OUTPUT_LED: OUTPUT s2, LED_PORT;display counter value on LEDs
070 LOAD s1, 00;RESET SUM
071 LOAD s2, 00;RESET SUM_CARRY
072 LOAD s3, 00;RESET COUNTER
073 return: STORE s1, SUM;store new counter value
074 STORE s2, SUM_CARRY
075 STORE s3, COUNT;STORE COUNTER VALUE
076 FETCH s1, ISR_preserve_s0;restore registers
077 FETCH s2, ISR_preserve_s1
078 FETCH s3, ISR_preserve_s2
079 RETURNI ENABLE
07A ;
07A ;
07A 
;**************************************************************************************
07A ; Interrupt Vector
07A 
;**************************************************************************************
07A ;
07A ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 4 - Resolving Operands

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_0, 40;OUTPUT DATA PORT FOR SINGLE BLINKING LED
000 CONSTANT LED_PORT, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT AUDIO_1, 00;input data port. this is an INPUT port.
000 CONSTANT AUDIO_2, 01;input data port. this is an INPUT port.
000 CONSTANT AUDIO_3, 02;input data port. this is an INPUT port.
000 CONSTANT AUDIO_4, 04;input data port. this is an INPUT port.
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 CONSTANT ISR_preserve_s4, 04;Preserve s3 contents during ISR
000 ;
000 CONSTANT SUM, 04;SUM OF THE ADDRESSES
000 CONSTANT COUNT, 06;COUNT UP TO 255
000 CONSTANT SUM_CARRY, 07;CARRY OF SUM USED TO OUTPUT LED
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00;CLEAR ALL
001 STORE s0, SUM
002 STORE s0, COUNT
003 STORE s0, SUM_CARRY
004 OUTPUT s0, LED_PORT
005 OUTPUT s0, LED_0
006 ;
006 ENABLE INTERRUPT
007 ;
007 
;**************************************************************************************
007 ; Main program
007 
;**************************************************************************************
007 ;
007 ; Display welcome message for design
007 ;
007 main_program: 
007 LOAD s1, 01
008 OUTPUT s1, LED_0; PUTS 1 INTO LED_0 (TURNS ON LED)
009 CALL delay_1s;WAITS 1 SECOND TO TURN OFF
00A LOAD s1, 00
00B OUTPUT s1, LED_0; PUTS 0 INTO LED_0, (TURNS OFF LED)
00C CALL delay_1s;WAITS ANOTEHR SECOND TO TURN ON
00D JUMP main_program
00E 
;**************************************************************************************
00E ; Software delay routines
00E 
;**************************************************************************************
00E ;
00E ; Delay of 1us.
00E ;
00E 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00E 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00E 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00E ; in the initiating code. Interrupts may effect software derived delays.
00E ;
00E 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00E ;
00E ; Registers used s0
00E ;
00E delay_1us: LOAD s0, delay_1us_constant
00F wait_1us: SUB s0, 01
010 JUMP NZ, wait_1us
011 RETURN
012 ;
012 ; Delay of 40us.
012 ;
012 ; Registers used s0, s1
012 ;
012 delay_40us: LOAD s1, 28;40 x 1us = 40us
013 wait_40us: CALL delay_1us
014 SUB s1, 01
015 JUMP NZ, wait_40us
016 RETURN
017 ;
017 ;
017 ; Delay of 1ms.
017 ;
017 ; Registers used s0, s1, s2
017 ;
017 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
018 wait_1ms: CALL delay_40us
019 SUB s2, 01
01A JUMP NZ, wait_1ms
01B RETURN
01C ;
01C ; Delay of 20ms.
01C ;
01C ; Delay of 20ms used during initialisation.
01C ;
01C ; Registers used s0, s1, s2, s3
01C ;
01C delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
01D wait_20ms: CALL delay_1ms
01E SUB s3, 01
01F JUMP NZ, wait_20ms
020 RETURN
021 ;
021 ; Delay of approximately 1 second.
021 ;
021 ; Registers used s0, s1, s2, s3, s4
021 ;
021 delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
022 wait_1s: CALL delay_20ms
023 SUB s4, 01
024 JUMP NZ, wait_1s
025 RETURN
026 ;
026 
;**************************************************************************************
026 ; Interrupt Service Routine (ISR)
026 
;**************************************************************************************
026 ;
026 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
026 ; on the 8 LEDs.
026 ;
026 ISR: STORE s1, ISR_preserve_s0;preserve register
027 STORE s2, ISR_preserve_s1
028 STORE s3, ISR_preserve_s2
029 FETCH s1, SUM;read current sum value
02A FETCH s2, SUM_CARRY;read carryout of the sums
02B FETCH s3, COUNT;reads count
02C ;;===================== ADD FIRST BYTE ================================
02C INPUT s5, AUDIO_1;INPUT INTO 1st BYTE
02D COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
02E JUMP C, ADD_BYTE_1;jump if S2 < 80 (POSITIVE NUMBER)
02F ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
02F XOR s5, ff
030 ADD s5, 01;CONVERTING 2's COMPLEMENT
031 ;; ADDS THIS TO SUM
031 ADD_BYTE_1: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
032 ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
033 ADD s3, 01;INCREMENT COUNTER
034 ;;===================== ADD SECOND BYTE ================================
034 INPUT s5, AUDIO_2;INPUT INTO 1st BYTE
035 COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
036 JUMP C, ADD_BYTE_2;jump if S2 < 80 (POSITIVE NUMBER)
037 ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
037 XOR s5, ff
038 ADD s5, 01;CONVERTING 2's COMPLEMENT
039 ;; ADDS THIS TO SUM
039 ADD_BYTE_2: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
03A ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
03B ADD s3, 01;INCREMENT COUNTER
03C ;;===================== ADD THIRD BYTE ================================
03C INPUT s5, AUDIO_3;INPUT INTO 1st BYTE
03D COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
03E JUMP C, ADD_BYTE_3;jump if S2 < 80 (POSITIVE NUMBER)
03F ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
03F XOR s5, ff
040 ADD s5, 01;CONVERTING 2's COMPLEMENT
041 ;; ADDS THIS TO SUM
041 ADD_BYTE_3: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
042 ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
043 ADD s3, 01;INCREMENT COUNTER
044 ;;===================== ADD FOURTH BYTE ================================
044 INPUT s5, AUDIO_4;INPUT INTO 1st BYTE
045 COMPARE s5, 80;COMPARES IT TO 1000_000 TO SEE IF ITS A NEGATIVE NUMBER
046 JUMP C, ADD_BYTE_4;jump if S2 < 80 (POSITIVE NUMBER)
047 ;; CONVERSION FROM 2's COMPLEMENT IF NEGATIVE
047 XOR s5, ff
048 ADD s5, 01;CONVERTING 2's COMPLEMENT
049 ;; ADDS THIS TO SUM
049 ADD_BYTE_4: ADD s1, s5;ADD INPUT INTO REGISTER 1 (OUR SUM)
04A ADDCY s2, 00;ADD THE CARRYOUT TO OUR REGISTER 2
04B ADD s3, 01;INCREMENT COUNTER
04C ;;============================================================
04C COMPARE s3, 00;IF COUNTER IS NOT 0 (OVER FLOW OF 255+1)
04D JUMP NZ, return;END INSTRUCTIOn
04E COMPARE s2, 80;IS IT BIGGER THAN 1000_0000?
04F JUMP C, H40; IF ITS NOT JUMP TO H40 AND THEN COMPARE
050 LOAD s2, ff; LOAD WITH 1111_1111
051 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
052 H40: COMPARE s2, 40;IS IT BIGGER THAN 100_0000?
053 JUMP C, H20; IF ITS NOT JUMP TO H20 AND THEN COMPARE
054 LOAD s2, fe; LOAD WITH 1111_1110
055 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
056 H20: COMPARE s2, 20;IS IT BIGGER THAN 10_0000?
057 JUMP C, H10; IF ITS NOT JUMP TO H40 AND THEN COMPARE
058 LOAD s2, fc; LOAD WITH 1111_1100
059 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
05A H10: COMPARE s2, 10;IS IT BIGGER THAN 1_0000?
05B JUMP C, H08; IF ITS NOT JUMP TO H40 AND THEN COMPARE
05C LOAD s2, f8; LOAD WITH 1111_1000
05D JUMP OUTPUT_LED; OUTPUTS IT INTO LED
05E H08: COMPARE s2, 08;IS IT BIGGER THAN 1000?
05F JUMP C, H04; IF ITS NOT JUMP TO H40 AND THEN COMPARE
060 LOAD s2, f0; LOAD WITH 1111_0000
061 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
062 H04: COMPARE s2, 04;IS IT BIGGER THAN 100?
063 JUMP C, H02; IF ITS NOT JUMP TO H40 AND THEN COMPARE
064 LOAD s2, e0; LOAD WITH 1110_0000
065 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
066 H02: COMPARE s2, 02;IS IT BIGGER THAN 10?
067 JUMP C, H01; IF ITS NOT JUMP TO H40 AND THEN COMPARE
068 LOAD s2, c0; LOAD WITH 1100_0000
069 JUMP OUTPUT_LED; OUTPUTS IT INTO LED
06A H01: COMPARE s2, 01;IS IT BIGGER THAN 1?
06B JUMP C, H00; IF ITS NOT JUMP TO H40 AND THEN COMPARE
06C LOAD s2, 80; LOAD WITH 1000_0000
06D JUMP OUTPUT_LED; OUTPUTS IT INTO LED
06E H00: LOAD s2, 00; LOAD WITH 0
06F OUTPUT_LED: OUTPUT s2, LED_PORT;display counter value on LEDs
070 LOAD s1, 00;RESET SUM
071 LOAD s2, 00;RESET SUM_CARRY
072 LOAD s3, 00;RESET COUNTER
073 return: STORE s1, SUM;store new counter value
074 STORE s2, SUM_CARRY
075 STORE s3, COUNT;STORE COUNTER VALUE
076 FETCH s1, ISR_preserve_s0;restore registers
077 FETCH s2, ISR_preserve_s1
078 FETCH s3, ISR_preserve_s2
079 RETURNI ENABLE
07A ;
07A ;
07A 
;**************************************************************************************
07A ; Interrupt Vector
07A 
;**************************************************************************************
07A ;
3FF ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 5 - Writing reformatted PSM file
           pracpico.fmt

PASS 6 - Writing assembler log file
           pracpico.log

PASS 7 - Writing coefficient file
           pracpico.coe

PASS 8 - Writing VHDL memory definition file
           pracpico.vhd

PASS 9 - Writing Verilog memory definition file
           pracpico.v

PASS 10 - Writing System Generator memory definition file
           pracpico.m

PASS 11 - Writing memory definition files
           pracpico.hex
           pracpico.dec
           pracpico.mem


KCPSM3 successful.

KCPSM3 complete.

